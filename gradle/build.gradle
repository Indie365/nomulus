buildscript {
  // Lock buildscript dependencies.
  configurations.classpath {
    resolutionStrategy.activateDependencyLocking()
  }

  dependencies {
    classpath 'com.google.cloud.tools:appengine-gradle-plugin:1.3.3'
    classpath "net.ltgt.gradle:gradle-errorprone-plugin:0.6.1"
    classpath 'org.sonatype.aether:aether-api:1.13.1'
    classpath 'org.sonatype.aether:aether-impl:1.13.1'
  }
}

plugins {
  id 'nebula.lint' version '10.4.2'
  // Config helper for annotation processors such as AutoValue and Dagger.
  // Ensures that source code is generated at an appropriate location.
  id 'net.ltgt.apt' version '0.19' apply false
  id 'net.ltgt.errorprone' version '0.6.1'
  id 'checkstyle'
  id "com.moowork.node" version "1.2.0"
}

apply plugin: google.registry.gradle.plugin.ReportUploaderPlugin

reportUploader {
  // Set the location where we want to upload the build results.
  // e.g. -P uploaderDestination=gcs://domain-registry-alpha-build-result-test
  //
  // If not set - the upload will be skipped
  destination = uploaderDestination

  // The location of the file containing the OAuth2 Google Cloud credentials.
  //
  // The file can contain a Service Account key file in JSON format from the
  // Google Developers Console or a stored user credential using the format
  // supported by the Cloud SDK.
  //
  // If no file is given - the default credentials are used.
  credentialsFile = uploaderCredentialsFile

  // If set to 'yes', each file will be uploaded to GCS in a separate thread.
  // This is MUCH faster.
  multithreadedUpload = uploaderMultithreadedUpload
}

apply from: 'dependencies.gradle'

// Provide defaults for all of the project properties.

// showAllOutput: boolean.  If true, dump all test output during the build.
if (!project.hasProperty('showAllOutput')) {
  ext.showAllOutput = 'false'
}

// Only do linting if the build is successful.
gradleLint.autoLintAfterFailure = false

// Paths to main and test sources.
ext.projectRootDir = "${rootDir}/.."
ext.javaDir = "${rootDir}/../java"
ext.javatestsDir = "${rootDir}/../javatests"

// Tasks to deploy/stage all App Engine services
task deploy {
  group = 'deployment'
  description = 'Deploys all services to App Engine.'
}

task stage {
  group = 'deployment'
  description = 'Generates application directories for all services.'
}

ext.constructMavenCoordinate = { deps, distinctMetadata ->
  if (deps.isEmpty()) {
    return
  }
  deps.each { ResolvedDependency dep ->
    if (dep.moduleGroup == "nomulus") {
      return
    }
    def artifactId = "${dep.moduleGroup}:${dep.moduleName}:${dep.moduleVersion}"
    distinctMetadata.add(artifactId)
    rootProject.constructMavenCoordinate(dep.children, distinctMetadata)
  }
}

allprojects {
  // Skip no-op project
  if (project.name == 'services') return

  repositories {
    if (rootProject.mavenUrl) {
      maven {
        url rootProject.mavenUrl
      }
    } else {
      mavenCentral()
    }
  }

  // This task generates a Maven coordinate for each resolved dependency and
  // stores them in the given file.
  task generateMavenCoordinateForDependency {
    doLast {
      def allconfigs = []
      def distinctMetadata = [] as Set
      if (!rootProject.mavenCoordinateFile) {
        throw new IllegalArgumentException("mavenCoordinateFile must be set")
      }
      def outputFile = new File(rootProject.mavenCoordinateFile)

      allconfigs.addAll(configurations)
      // This only adds buildscript dependencies declare in this project.
      allconfigs.addAll(buildscript.configurations)

      allconfigs.each {
        if (!it.isCanBeResolved()) {
          return
        }
        rootProject.constructMavenCoordinate(
          it.resolvedConfiguration.firstLevelModuleDependencies,
          distinctMetadata)
      }

      distinctMetadata.each { metadata ->
        outputFile.append("${metadata}\n")
      }
    }
  }
}

subprojects {
  // Skip no-op project
  if (project.name == 'services') return

  buildscript {
    // Lock buildscript dependencies.
    configurations.classpath {
      resolutionStrategy.activateDependencyLocking()
    }
  }

  // Lock application dependencies.
  dependencyLocking {
    lockAllConfigurations()
  }

  def services = [':services:default',
                  ':services:backend',
                  ':services:tools',
                  ':services:pubapi']

  def environments = ['production', 'sandbox', 'alpha', 'crash']

  def projects = ['production': 'domain-registry',
                  'sandbox'   : 'domain-registry-sandbox',
                  'alpha'     : 'domain-registry-alpha',
                  'crash'     : 'domain-registry-crash']

  // Set up all of the deployment projects.
  if (services.contains(project.path)) {

    def environment = rootProject.findProperty("environment")
    if (environment == null) {
      environment = 'alpha'
    }
    def gcpProject = projects[environment]
    if (gcpProject == null) {
      throw new GradleException("-Penvironment must be one of ${environments}.")
    }

    apply plugin: 'war'

    // Set this directory before applying the appengine plugin so that the
    // plugin will recognize this as an app-engine standard app (and also
    // obtains the appengine-web.xml from the correct location)
    project.convention.plugins['war'].webAppDirName =
        "../../../java/google/registry/env/${environment}/${project.name}"

    apply plugin: 'com.google.cloud.tools.appengine'

    // Get the web.xml file for the service.
    war {
      webInf {
        from "../../../java/google/registry/env/common/${project.name}/WEB-INF"
      }
    }

    def coreResourcesDir = "${rootDir}/core/build/resources/main"
    war {
      from("${coreResourcesDir}/google/registry/ui/html") {
        include "*.html"
      }
    }

    if (project.path == ":services:default") {
      war {
        from("${coreResourcesDir}/google/registry/ui") {
          include "registrar_bin.js"
          if (environment != "production") {
            include "registrar_bin.js.map"
          }
          into("assets/js")
        }
        from("${coreResourcesDir}/google/registry/ui/css") {
          include "registrar*"
          into("assets/css")
        }
        from("${coreResourcesDir}/google/registry/ui/assets/images") {
          include "**/*"
          into("assets/images")
        }
      }
    }

    appengine {
      deploy {
        project = gcpProject
      }
    }

    dependencies {
      compile project(':core')
    }

    rootProject.deploy.dependsOn appengineDeploy
    rootProject.stage.dependsOn appengineStage

    // Return early, do not apply the settings below.
    return
  }

  apply plugin: 'java'
  apply plugin: 'nebula.lint'
  apply plugin: 'net.ltgt.apt'
  apply plugin: 'net.ltgt.errorprone'
  apply plugin: 'checkstyle'

  // Checkstyle should run as part of the testing task
  tasks.test.dependsOn tasks.checkstyleMain
  tasks.test.dependsOn tasks.checkstyleTest

  dependencies {
    // compatibility with Java 8
    errorproneJavac("com.google.errorprone:javac:9+181-r4173-1")
    errorprone("com.google.errorprone:error_prone_core:2.3.3")
  }

  tasks.withType(JavaCompile).configureEach {
    options.compilerArgs << "-Werror"
    options.errorprone.disableWarningsInGeneratedCode = true
    options.errorprone.errorproneArgumentProviders.add([
        asArguments: {
          return ['-XepExcludedPaths:.*/build/generated/.*']
        }] as CommandLineArgumentProvider)
  }

  version = '1.0'
  sourceCompatibility = '1.8'
  targetCompatibility = '1.8'

  compileJava { options.encoding = "UTF-8" }

  gradleLint.rules = [
      // Checks if Gradle wrapper is up-to-date
      'archaic-wrapper',
      // Checks for indirect dependencies with dynamic version spec. Best
      // practice calls for declaring them with specific versions.
      'undeclared-dependency',
      'unused-dependency'
      // TODO(weiminyu): enable more dependency checks
  ]

  if (project.name == 'third_party') return

// Path to code generated with annotation processors. Note that this path is
// chosen by the 'net.ltgt.apt' plugin, and may change if IDE-specific plugins
// are applied, e.g., 'idea' or 'eclipse'
  def aptGeneratedDir = "${project.buildDir}/generated/source/apt/main"
  def aptGeneratedTestDir = "${project.buildDir}/generated/source/apt/test"

  def commonlyExcludedResources = ['**/*.java', '**/BUILD']

  sourceSets {
    main {
      java {
        srcDirs = [
            rootProject.javaDir,
            aptGeneratedDir
        ]
      }
      resources {
        srcDirs = [
            rootProject.javaDir
        ]
        exclude commonlyExcludedResources
      }
    }
    test {
      java {
        srcDirs = [
            rootProject.javatestsDir,
            aptGeneratedTestDir
        ]
      }
      resources {
        srcDirs = [
            rootProject.javatestsDir,
        ]
        exclude commonlyExcludedResources
      }
    }
  }

  test {
    testLogging.showStandardStreams = Boolean.parseBoolean(showAllOutput)
  }

  if (project.name == 'core') return

  ext.relativePath = "google/registry/${project.name}"

  sourceSets.each {
    it.java {
      include "${project.relativePath}/"
    }
    it.resources {
      include "${project.relativePath}/"
    }
  }
  project(':core').sourceSets.each {
    it.java {
      exclude "${project.relativePath}/"
    }
    it.resources {
      exclude "${project.relativePath}/"
    }
  }
}
