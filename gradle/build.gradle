buildscript {
  // Lock buildscript dependencies.
  configurations.classpath {
    resolutionStrategy.activateDependencyLocking()
  }

  dependencies {
    classpath 'com.google.cloud.tools:appengine-gradle-plugin:1.3.3'
    classpath "net.ltgt.gradle:gradle-errorprone-plugin:0.6.1"
    classpath 'org.sonatype.aether:aether-api:1.13.1'
    classpath 'org.sonatype.aether:aether-impl:1.13.1'
  }
}

plugins {
  id 'maven-publish'
  id 'nebula.lint' version '10.4.2'
  // Config helper for annotation processors such as AutoValue and Dagger.
  // Ensures that source code is generated at an appropriate location.
  id 'net.ltgt.apt' version '0.19' apply false
  id 'net.ltgt.errorprone' version '0.6.1'
  id 'checkstyle'
  id "com.moowork.node" version "1.2.0"
}

apply plugin: google.registry.gradle.plugin.GcsReportUploaderPlugin

gcsReportUploader {
  // Set the bucket here to upload build results to a GCS bucket.
  // e.g. -P gcsBucket=domain-registry-alpha-build-result-test
  //
  // If no bucket it set - the uploading will be skipped.
  bucket = gcsBucket

  // The location of the file containing the OAuth2 Google Cloud credentials.
  //
  // The file can contain a Service Account key file in JSON format from the
  // Google Developers Console or a stored user credential using the format
  // supported by the Cloud SDK.
  //
  // If no file is given - the default credentials are used.
  credentialsFile = gcsCredentialsFile

  // If set to 'yes', each file will be uploaded to GCS in a separate thread.
  // This is MUCH faster.
  multithreadedUpload = gcsMultithreadedUpload
}

apply from: 'dependencies.gradle'

// Provide defaults for all of the project properties.

// showAllOutput: boolean.  If true, dump all test output during the build.
if (!project.hasProperty('showAllOutput')) {
  ext.showAllOutput = 'false'
}

// Only do linting if the build is successful.
gradleLint.autoLintAfterFailure = false

// Paths to main and test sources.
ext.javaDir = "${rootDir}/../java"
ext.javatestsDir = "${rootDir}/../javatests"

// Tasks to deploy/stage all App Engine services
task deploy {
  group = 'deployment'
  description = 'Deploys all services to App Engine.'
}

task stage {
  group = 'deployment'
  description = 'Generates application directories for all services.'
}


if (publishUrl) {
  publishing {
    repositories {
      maven {
        url publishUrl
      }
    }
  }
}

ext.processedDependencies = [] as Set<String>
ext.processDependencies = { Set<ResolvedDependency> deps ->

  if (deps.isEmpty()) {
    return
  }
  deps.each { ResolvedDependency dep ->
    if (dep.moduleGroup == "nomulus" ||
        rootProject.processedDependencies.contains(dep.module.toString())) {
      return
    }
    def name = "${dep.moduleGroup}_${dep.moduleName}_${dep.moduleVersion}"
    rootProject.publishing {
      publications {
        "${name}"(MavenPublication) {
          groupId = dep.moduleGroup
          artifactId = dep.moduleName
          version = dep.moduleVersion
          dep.moduleArtifacts.each { moduleArtifact ->
            artifact(moduleArtifact.file) {
              classifier = moduleArtifact.classifier
            }
          }
          if (!dep.children.isEmpty()) {
            pom.withXml {
              def dependenciesNode = asNode().appendNode("dependencies")
              dep.children.each {
                def dependencyNode =
                    dependenciesNode.appendNode("dependency")
                dependencyNode.appendNode("groupId", it.moduleGroup)
                dependencyNode.appendNode("artifactId", it.moduleName)
                dependencyNode.appendNode("version", it.moduleVersion)
              }
            }
          }
        }
      }
    }
    rootProject.processedDependencies.add(dep.module.toString())
    rootProject.processDependencies(dep.children)
  }
}

allprojects {
  // Skip no-op project
  if (project.name == 'services') return

  repositories {
    if (rootProject.repositoryUrl) {
      maven {
        url rootProject.repositoryUrl
      }
    } else {
      mavenCentral()
    }
  }

  ext.generateDependencyPublications = {
    def allconfigs = []

    allconfigs.addAll(configurations)
    // This only adds buildscript dependencies declare in this project.
    allconfigs.addAll(buildscript.configurations)

    allconfigs.each {
      if (!it.isCanBeResolved()) {
        return
      }
      rootProject.processDependencies(
          it.resolvedConfiguration.firstLevelModuleDependencies)
    }
  }

  ext.urlExists = { url ->
    def connection = (HttpURLConnection) url.openConnection()
    connection.setRequestMethod("HEAD")
    connection.connect()
    if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
      return true
    } else {
      return false
    }
  }

  ext.writeMetadata = { resolvedArtifact, url, gitRepositoryPath ->
    def groupId = resolvedArtifact.moduleVersion.id.group
    def artifactId = resolvedArtifact.moduleVersion.id.name
    def version = resolvedArtifact.moduleVersion.id.version
    def relativeFileName =
        [groupId, artifactId, 'README.domainregistry'].join('/')
    def metadataFile = new File(gitRepositoryPath, relativeFileName)
    metadataFile.parentFile.mkdirs()
    def writer = metadataFile.newWriter()
    writer << "Name: ${artifactId}\n"
    writer << "Url: ${url}\n"
    writer << "Version: ${version}\n"
    writer.close()
  }

// This task generates a metadata file for each resolved dependency artifact.
// The file contains the name, url and version for the artifact.
  task generateDependencyMetadata {
    doLast {
      def distinctResolvedArtifacts = project.ext.getDistinctResolvedArtifacts()
      def defaultLayout = new org.sonatype.aether.util.layout.MavenDefaultLayout()

      distinctResolvedArtifacts.values().each { resolvedArtifact ->
        def artifact = new org.sonatype.aether.util.artifact.DefaultArtifact(
            resolvedArtifact.id.componentIdentifier.toString())
        for (repository in project.repositories) {
          def mavenRepository = (MavenArtifactRepository) repository
          def repositoryUri = URI.create(mavenRepository.url.toString())
          def artifactUri = repositoryUri.resolve(defaultLayout.getPath(artifact))
          if (project.ext.urlExists(artifactUri.toURL())) {
            project.ext.writeMetadata(
                resolvedArtifact,
                artifactUri.toURL(),
                project.findProperty('privateRepository') + "/${project.name}")
            break
          }
        }
      }
    }
  }
}

subprojects {
  // Skip no-op project
  if (project.name == 'services') return

  buildscript {
    // Lock buildscript dependencies.
    configurations.classpath {
      resolutionStrategy.activateDependencyLocking()
    }
  }

  // Lock application dependencies.
  dependencyLocking {
    lockAllConfigurations()
  }

  apply plugin: 'maven-publish'

  def services = [':services:default',
                  ':services:backend',
                  ':services:tools',
                  ':services:pubapi']

  def environments = ['production', 'sandbox', 'alpha', 'crash']

  def projects = ['production': 'domain-registry',
                  'sandbox'   : 'domain-registry-sandbox',
                  'alpha'     : 'domain-registry-alpha',
                  'crash'     : 'domain-registry-crash']

  // Set up all of the deployment projects.
  if (services.contains(project.path)) {

    def environment = rootProject.findProperty("environment")
    if (environment == null) {
      environment = 'alpha'
    }
    def gcpProject = projects[environment]
    if (gcpProject == null) {
      throw new GradleException("-Penvironment must be one of ${environments}.")
    }

    apply plugin: 'war'

    // Set this directory before applying the appengine plugin so that the
    // plugin will recognize this as an app-engine standard app (and also
    // obtains the appengine-web.xml from the correct location)
    project.convention.plugins['war'].webAppDirName =
        "../../../java/google/registry/env/${environment}/${project.name}"

    apply plugin: 'com.google.cloud.tools.appengine'

    // Get the web.xml file for the service.
    war {
      webInf {
        from "../../../java/google/registry/env/common/${project.name}/WEB-INF"
      }
    }

    def coreResourcesDir = "${rootDir}/core/build/resources/main"
    war {
      from("${coreResourcesDir}/google/registry/ui/html") {
        include "*.html"
      }
    }

    if (project.path == ":services:default") {
      war {
        from("${coreResourcesDir}/google/registry/ui") {
          include "registrar_bin.js"
          if (environment != "production") {
            include "registrar_bin.js.map"
          }
          into("assets/js")
        }
        from("${coreResourcesDir}/google/registry/ui/css") {
          include "registrar*"
          into("assets/css")
        }
        from("${coreResourcesDir}/google/registry/ui/assets/images") {
          include "**/*"
          into("assets/images")
        }
      }
    }

    appengine {
      deploy {
        // TODO: change this to a variable.
        project = gcpProject
      }
    }

    dependencies {
      compile project(':core')
    }

    rootProject.deploy.dependsOn appengineDeploy
    rootProject.stage.dependsOn appengineStage

    // Return early, do not apply the settings below.
    return
  }

  apply plugin: 'java'
  apply plugin: 'nebula.lint'
  apply plugin: 'net.ltgt.apt'
  apply plugin: 'net.ltgt.errorprone'
  apply plugin: 'checkstyle'

  // Checkstyle should run as part of the testing task
  tasks.test.dependsOn tasks.checkstyleMain
  tasks.test.dependsOn tasks.checkstyleTest

  dependencies {
    // compatibility with Java 8
    errorproneJavac("com.google.errorprone:javac:9+181-r4173-1")
    errorprone("com.google.errorprone:error_prone_core:2.3.2")
  }

  tasks.withType(JavaCompile).configureEach {
    options.compilerArgs << "-Werror"
    options.errorprone.disableWarningsInGeneratedCode = true
    options.errorprone.errorproneArgumentProviders.add([
        asArguments: {
          return ['-XepExcludedPaths:.*/build/generated/.*']
        }] as CommandLineArgumentProvider)
  }

  version = '1.0'
  sourceCompatibility = '1.8'
  targetCompatibility = '1.8'

  compileJava { options.encoding = "UTF-8" }

  gradleLint.rules = [
      // Checks if Gradle wrapper is up-to-date
      'archaic-wrapper',
      // Checks for indirect dependencies with dynamic version spec. Best
      // practice calls for declaring them with specific versions.
      'undeclared-dependency',
      'unused-dependency'
      // TODO(weiminyu): enable more dependency checks
  ]

  if (project.name == 'third_party') return

// Path to code generated with annotation processors. Note that this path is
// chosen by the 'net.ltgt.apt' plugin, and may change if IDE-specific plugins
// are applied, e.g., 'idea' or 'eclipse'
  def aptGeneratedDir = "${project.buildDir}/generated/source/apt/main"
  def aptGeneratedTestDir = "${project.buildDir}/generated/source/apt/test"

  def commonlyExcludedResources = ['**/*.java', '**/BUILD']

  sourceSets {
    main {
      java {
        srcDirs = [
            rootProject.javaDir,
            aptGeneratedDir
        ]
      }
      resources {
        srcDirs = [
            rootProject.javaDir
        ]
        exclude commonlyExcludedResources
      }
    }
    test {
      java {
        srcDirs = [
            rootProject.javatestsDir,
            aptGeneratedTestDir
        ]
      }
      resources {
        srcDirs = [
            rootProject.javatestsDir,
        ]
        exclude commonlyExcludedResources
      }
    }
  }

  test {
    testLogging.showStandardStreams = Boolean.parseBoolean(showAllOutput)
  }

  if (project.name == 'core') return

  ext.relativePath = "google/registry/${project.name}"

  sourceSets.each {
    it.java {
      include "${project.relativePath}/"
    }
    it.resources {
      include "${project.relativePath}/"
    }
  }
  project(':core').sourceSets.each {
    it.java {
      exclude "${project.relativePath}/"
    }
    it.resources {
      exclude "${project.relativePath}/"
    }
  }
}

generateDependencyPublications()
