// Copyright 2019 The Nomulus Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package google.registry.model.transaction;

import static com.google.common.truth.Truth.assertThat;
import static org.joda.time.DateTimeZone.UTC;
import static org.testcontainers.containers.PostgreSQLContainer.POSTGRESQL_PORT;

import com.google.common.base.Charsets;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import com.google.common.io.Resources;
import google.registry.persistence.HibernateSchemaExporter;
import google.registry.persistence.PersistenceModule;
import google.registry.persistence.PersistenceXmlUtility;
import google.registry.testing.FakeClock;
import java.io.File;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.sql.Connection;
import java.sql.Driver;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import javax.persistence.EntityManagerFactory;
import org.hibernate.cfg.Environment;
import org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor;
import org.hibernate.jpa.boot.spi.Bootstrap;
import org.joda.time.DateTime;
import org.junit.rules.ExternalResource;
import org.testcontainers.containers.JdbcDatabaseContainer;
import org.testcontainers.containers.PostgreSQLContainer;

/**
 * JUnit Rule to provision {@link JpaTransactionManagerImpl} backed by {@link PostgreSQLContainer}.
 *
 * <p>This rule also replaces the {@link JpaTransactionManagerImpl} provided by {@link
 * TransactionManagerFactory} with the {@link JpaTransactionManagerImpl} generated by the rule
 * itself, so that all SQL queries will be sent to the database instance created by {@link
 * PostgreSQLContainer} to achieve test purpose.
 */
public class JpaTransactionManagerRule extends ExternalResource {
  private static final String GOLDEN_SCHEMA_SQL_PATH = "sql/schema/nomulus.golden.sql";
  private static final String DB_CLEANUP_SQL_PATH =
      "google/registry/model/transaction/cleanup_database.sql";
  private static final String MANAGEMENT_DB_NAME = "management";
  private static final String POSTGRES_DB_NAME = "postgres";

  private final DateTime now = DateTime.now(UTC);
  private final FakeClock clock = new FakeClock(now);
  private final String initScriptPath;
  private final ImmutableList<Class> extraEntityClasses;
  private final ImmutableMap userProperties;

  private static final JdbcDatabaseContainer database = create();
  private static final HibernateSchemaExporter exporter =
      HibernateSchemaExporter.create(
          database.getJdbcUrl(), database.getUsername(), database.getPassword());
  private EntityManagerFactory emf;
  private JpaTransactionManager cachedTm;

  private JpaTransactionManagerRule(
      String initScriptPath,
      ImmutableList<Class> extraEntityClasses,
      ImmutableMap<String, String> userProperties) {
    this.initScriptPath = initScriptPath;
    this.extraEntityClasses = extraEntityClasses;
    this.userProperties = userProperties;
  }

  private static JdbcDatabaseContainer create() {
    PostgreSQLContainer container = new PostgreSQLContainer().withDatabaseName(MANAGEMENT_DB_NAME);
    container.start();
    Runtime.getRuntime().addShutdownHook(new Thread(() -> container.close()));
    return container;
  }

  @Override
  public void before() throws Exception {
    executeSql(MANAGEMENT_DB_NAME, readSqlInClassPath(DB_CLEANUP_SQL_PATH));
    executeSql(POSTGRES_DB_NAME, readSqlInClassPath(initScriptPath));
    if (!extraEntityClasses.isEmpty()) {
      File tempSqlFile = File.createTempFile("tempSqlFile", ".sql");
      tempSqlFile.deleteOnExit();
      exporter.export(extraEntityClasses, tempSqlFile);
      executeSql(
          POSTGRES_DB_NAME,
          new String(Files.readAllBytes(tempSqlFile.toPath()), StandardCharsets.UTF_8));
    }

    ImmutableMap properties = PersistenceModule.providesDefaultDatabaseConfigs();
    if (!userProperties.isEmpty()) {
      // If there are user properties, create a new properties object with these added.
      ImmutableMap.Builder builder = properties.builder();
      builder.putAll(userProperties);
      properties = builder.build();
    }
    assertNormalActiveConnection();
    emf =
        createEntityManagerFactory(
            getJdbcUrlFor(POSTGRES_DB_NAME),
            database.getUsername(),
            database.getPassword(),
            properties,
            extraEntityClasses);
    JpaTransactionManagerImpl txnManager = new JpaTransactionManagerImpl(emf, clock);
    cachedTm = TransactionManagerFactory.jpaTm;
    TransactionManagerFactory.jpaTm = txnManager;
  }

  @Override
  public void after() {
    TransactionManagerFactory.jpaTm = cachedTm;
    if (emf != null) {
      emf.close();
      emf = null;
    }
    cachedTm = null;
    assertNormalActiveConnection();
  }

  /**
   * This function throws exception if it detects connection leak by checking the metadata table
   * pg_stat_activity.
   */
  private void assertNormalActiveConnection() {
    try (Connection conn = createConnection(POSTGRES_DB_NAME);
        Statement statement = conn.createStatement()) {
      ResultSet rs =
          statement.executeQuery(
              "SELECT COUNT(1) FROM pg_stat_activity WHERE usename = '"
                  + database.getUsername()
                  + "'");
      rs.next();
      long activeConns = rs.getLong(1);
      // There should be only 1 active connection which is executing this query
      assertThat(activeConns).isEqualTo(1L);
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  private static String readSqlInClassPath(String sqlScriptPath) {
    try {
      return Resources.toString(Resources.getResource(sqlScriptPath), Charsets.UTF_8);
    } catch (IOException e) {
      throw new UncheckedIOException(e);
    }
  }

  private void executeSql(String dbName, String sqlScript) {
    try (Connection conn = createConnection(dbName);
        Statement statement = conn.createStatement()) {
      statement.execute(sqlScript);
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  private String getJdbcUrlFor(String dbName) {
    // Disable Postgres driver use of java.util.logging to reduce noise at startup time
    return "jdbc:postgresql://"
        + database.getContainerIpAddress()
        + ":"
        + database.getMappedPort(POSTGRESQL_PORT)
        + "/"
        + dbName
        + "?loggerLevel=OFF";
  }

  private Connection createConnection(String dbName) {
    final Properties info = new Properties();
    info.put("user", database.getUsername());
    info.put("password", database.getPassword());
    final Driver jdbcDriverInstance = database.getJdbcDriverInstance();
    try {
      return jdbcDriverInstance.connect(getJdbcUrlFor(dbName), info);
    } catch (SQLException e) {
      throw new RuntimeException(e);
    }
  }

  /** Constructs the {@link EntityManagerFactory} instance. */
  private static EntityManagerFactory createEntityManagerFactory(
      String jdbcUrl,
      String username,
      String password,
      ImmutableMap<String, String> configs,
      ImmutableList<Class> extraEntityClasses) {
    HashMap<String, String> properties = Maps.newHashMap(configs);
    properties.put(Environment.URL, jdbcUrl);
    properties.put(Environment.USER, username);
    properties.put(Environment.PASS, password);

    ParsedPersistenceXmlDescriptor descriptor =
        PersistenceXmlUtility.getParsedPersistenceXmlDescriptor();

    extraEntityClasses.stream().map(Class::getName).forEach(descriptor::addClasses);
    return Bootstrap.getEntityManagerFactoryBuilder(descriptor, properties).build();
  }

  /** Returns the {@link FakeClock} used by the underlying {@link JpaTransactionManagerImpl}. */
  public FakeClock getTxnClock() {
    return clock;
  }

  /** Builder for {@link JpaTransactionManagerRule}. */
  public static class Builder {
    private String initScript;
    private List<Class> extraEntityClasses = new ArrayList<Class>();
    private Map<String, String> userProperties = new HashMap<String, String>();

    /**
     * Sets the SQL script to be used to initialize the database. If not set,
     * sql/schema/nomulus.golden.sql will be used.
     */
    public Builder withInitScript(String initScript) {
      this.initScript = initScript;
      return this;
    }

    /** Adds annotated class(es) to the known entities for the database. */
    public Builder withEntityClass(Class... classes) {
      this.extraEntityClasses.addAll(ImmutableSet.copyOf(classes));
      return this;
    }

    /** Adds the specified property to those used to initialize the transaction manager. */
    public Builder withProperty(String name, String value) {
      this.userProperties.put(name, value);
      return this;
    }

    /** Builds a {@link JpaTransactionManagerRule} instance. */
    public JpaTransactionManagerRule build() {
      if (initScript == null) {
        initScript = GOLDEN_SCHEMA_SQL_PATH;
      }
      return new JpaTransactionManagerRule(
          initScript,
          ImmutableList.copyOf(extraEntityClasses),
          ImmutableMap.copyOf(userProperties));
    }
  }
}
