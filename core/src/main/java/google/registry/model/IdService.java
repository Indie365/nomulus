// Copyright 2021 The Nomulus Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package google.registry.model;

import static com.google.common.base.Preconditions.checkState;

import com.google.appengine.api.datastore.DatastoreServiceFactory;
import com.google.common.flogger.FluentLogger;
import google.registry.beam.common.RegistryPipelineWorkerInitializer;
import google.registry.config.RegistryEnvironment;
import google.registry.model.annotations.DeleteAfterMigration;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Supplier;

/**
 * Allocates a globally unique {@link Long} number to use as a {@code @Id}, which is usually used as
 * (part) of the primary SQL key.
 *
 * <p>Normally, the ID is generated by Datastore. In unit tests, a self allocated ID based on a
 * monotically increasing atomic long is used. An ID supplier can also be set which overrides the
 * default behavior, however that should only be used in a Beam pipeline to get around the
 * limitation of Beam's inability to use GAE SDK to access Datastore. The override should be used
 * with great care lest it results in irreversable data corruption.
 *
 * @see #setIdSupplier(Supplier)
 */
@DeleteAfterMigration
public final class IdService {

  private static final FluentLogger logger = FluentLogger.forEnclosingClass();

  private IdService() {}

  private static Supplier<Long> idSupplier =
      RegistryEnvironment.UNITTEST.equals(RegistryEnvironment.get())
          ? SelfAllocatedIdSupplier.getInstance()
          : DatastoreIdSupplier.getInstance();

  /**
   * Provides a {@link Supplier} of ID that overrides the default.
   *
   * Currently, the only use case for an override is in the Beam pipeline, where access to Datastore
   * is not possible throught the App Engine API. One should use this it should only be used The override to self allocate the ID. Other than in tests (which already self allocates), it is
   * almost always a bad idea to self allocate an ID, which is used as the primary key in the
   * database almost universally. This override should only be used when accessing datastore is not
   * possible and when the allocated ID is not important or persisted back to the database. One
   * example is the RDE beam pipeline where we create EPP resource entities from history entries
   * which are then marshalled into XML elements in the RDE deposits.
   */
  // private static boolean isSelfAllocated = false;
  public static void setIdSupplier(Supplier<Long> idSupplier) {
    checkState(
        "true".equals(System.getProperty(RegistryPipelineWorkerInitializer.PROPERTY, "false")),
        "Can only set ID supplier in a Beam pipeline");
    logger.atWarning().log("Using ID supplier override!");
    IdService.idSupplier = idSupplier;
  }



  /**
   * Make the ID self allocated in the current JVM.
   *
   * <p>Always use caution when enabling this option as it can be very dangerous when you write
   * these self-allocated IDs back to the database.
   *
   * @see #isSelfAllocated
   */
  // public static void useSelfAllocatedId() {
  //  isSelfAllocated = true;
  // }

  // private static boolean isSelfAllocated() {
  //  return isSelfAllocated || RegistryEnvironment.UNITTEST.equals(RegistryEnvironment.get());
  // }

  /** Allocates an id. */
  // TODO(b/201547855): Find a way to allocate a unique ID without datastore.
  public static long allocateId() {
    return idSupplier.get();
  }

  private static class DatastoreIdSupplier implements Supplier<Long> {

    private static final DatastoreIdSupplier INSTANCE = new DatastoreIdSupplier();

    /**
     * A placeholder String passed into DatastoreService.allocateIds that ensures that all ids are
     * initialized from the same id pool.
     */
    private static final String APP_WIDE_ALLOCATION_KIND = "common";

    public static DatastoreIdSupplier getInstance() {
      return INSTANCE;
    }

    @Override
    public Long get() {
      return DatastoreServiceFactory.getDatastoreService()
          .allocateIds(APP_WIDE_ALLOCATION_KIND, 1)
          .iterator()
          .next()
          .getId();
    }
  }

  public static class SelfAllocatedIdSupplier implements Supplier<Long> {

    private static final SelfAllocatedIdSupplier INSTANCE = new SelfAllocatedIdSupplier();

    /**
     * Counts of used ids for self allocating IDs.
     *
     * <p>//@see #isSelfAllocated
     */
    private static final AtomicLong nextSelfAllocatedId = new AtomicLong(1); // ids cannot be zero

    public static SelfAllocatedIdSupplier getInstance() {
      return INSTANCE;
    }

    @Override
    public Long get() {
      return nextSelfAllocatedId.getAndIncrement();
    }

    public void reset() {
      nextSelfAllocatedId.set(1);
    }
  }
}
